# 运行时区域

<img src="https://vip2.loli.io/2022/09/08/JadjNU9risbgu5O.png" alt="image-20220908205948911" style="zoom:50%;" />

## 程序计数器

> `线程私有`当前线程所执行的字节码的行号指示器，辅助完成分支、跳转、循环、异常处理、线程恢复

## Java虚拟机栈

> `线程私有` 存储局部变量表、操作数栈帧、动态连接、方法出口。方法的调用->执行完毕，对应着栈帧的入栈->出栈。
>
> StackOverflowError、OutOfMemoryError

1. `局部变量`存放了**编译期**可知(槽数量确定)的各种Java虚拟机基本数据类型、对象引用(起始指针、句柄或者其他相关的位置)以及returnAddress(指向字节码指令的地址)。每种数据类型占用的存储空间以局部变量槽(slot,32bit/per)来表示。
2. `操作数栈帧`
3. `动态链接`
4. `方法出口`

## 本地方法栈

> `线程私有`类似与虚拟机栈
>
> StackOverflowError、OutOfMemoryError

## Java堆

> `线程共享`垃圾回收器管理的内存区域，存放基本所有的对象实例以及数组。由于即时编译技术的进步，有些场景可能存在栈上分配、标量替换等优化
>
> OutOfMemoryError

## 方法区

> `线程共享`被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存

在JDK8以后，已经把原本放在永久代的字符串常量池、静态变量池移出，全部迁移到了**元空间**

### 运行时常量池

> 方法区的一部分。存放类加载后，Class文件中的常量池表(编译期生成的字面量、符号引用)，具备动态性，String类的intern()方法
>
> OutOfMemoryError

## 直接内存

> 并不是运行时数据区域的一部分。
>
> 物理内存的限制(实际内存、swap、分页文件), OutOfMemoryError

​	在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

# 对象探秘

> HotSpot、内存区域Java堆为例

## 对象的创建

```java
A a = new A();	
```

1. JVM碰到new关键字时,检查常量池中是否存在类的符号引用
2. 然后判断符号引用代表的类是否被加载->解析->初始化
3. 类加载通过后，为新对象分配内存
4. 为对象设置必要的信息。是哪个类的实例、元数据指针、GC分代年龄、哈希码(延迟到object::hashCode方法调用)
5. 上述流程，已经产生了一个没有数据初始化的对象，此时final字段已经赋值成了预期的数据，但是其他字段还是默认零值。然而对于Java程序而言，则还需要调用构造函数，即Class文件中的<init>()方法，按照代码对对象进行初始化。

### 怎样分配对象内存

由于对象的内存大小，在类被加载完成后已经确定，那么对象的内存分配则等同于在Java最终划分出一块固定大小的内存。

1. 如果Java堆是规整的(空闲区域与使用区域分开)，则可以使用`碰撞指针`，Serial、ParNew
2. 否则则需要维护一个哪块内存可用以及大小的表，分配时在列表中寻找。`空闲列表`

### 对象内存分配的线程安全问题

1. CAS + 失败重试，保证更新操作的原子性

2. 在每个线程中预分配一块小内存，TLAB(Thread Local Allocation Buffer)本地线程分配缓冲区，哪个线程需要分配内存就直接使用其本地缓冲区中的，本地不够时再加锁申请。

   **-XX:+/-UseTLAB**

## 对象的内存布局

> 对象头、实例数据、对齐填充

1. `对象头`

+ 存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
+ 类型指针，即对象指向它的类型元数据的指针,如果对象是一个Java数组，还必须有一块用于记录数组长度

2. `实例数据`代码里面所定义的各种类型的字段内容，父类继承下来的、子类中定义的字段
3. `对齐填充`并不是一定存在，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是**8字节**的整数倍