# 垃圾回收

1. 回收哪一些内存
   + 栈中的数据，伴随着函数的调用执行自行清除，无需回收
   + 堆。存放对象实例，需要
   + 方法区存放常量、静态变量以及编译后的代码数据，需要
2. 什么时候回收
   + 引用计数器
   + 可达性分析
     + GC ROOT
3. 怎么回收
   + 垃圾回收算法

## 垃圾回收算法

### 分代收集理论

1. `弱分代假说`绝大多数对象朝生夕灭，用完就丢
2. `强分代假说` 熬过越多次垃圾回收过程的对象越难以消亡，用了还想用

出于这两个分代假说，收集器应该将Java堆划分出不同的区域，然后根据**年龄**分配到不同区域之中存储，并采用不同的策略进行回收。

3. `跨代引用假说` 跨代引用占极少数

对新生代进行标记，不予回收，熬过GC成为老年代后，便不存在跨代引用了。

### 标记-清除

1. 标记需要回收的**所有**对象
2. 标记完成后，同意对标记对象进行回收

#### 缺点

1. 效率不稳定，如果大部分对象都需要被回收，则标记、清除的执行效率会伴随着数量的增加而降低
2. 会产生大量不连续的内存碎片

### 标记-复制

1. 将内存区分为大小相等的两块
2. 标记存活的对象
3. 将所有的存活对象复制到另一份空闲区域，清空当前区域

#### 缺点

1. 浪费了一半的空间
2. 如果大部分对象存活，会带来较大的复制开销

#### 优点

1. 整区操作，不会产生碎片
2. 实现简单、运行高效

#### 改进

将**新生代**区域分成两个部分`Survivor`(S0、S1)和`Eden`,分别占用20%(10% + 10%)以及80%的大小，每次使用一个survivor以及整个Eden。

1. 将Eden和S中使用的区域复制到S中的空闲区域
2. 有可能S空闲区域不够存储存活下来的对象，因此需要老年代作空间的分配担保，允许部分对象直接进入老年代。

### 标记-整理

