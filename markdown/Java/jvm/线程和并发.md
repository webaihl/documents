# 并发

## 硬件问题

> 高速缓存缓解了CPU与内存之间存在速度差异，却引入了**缓存一致性**的问题

## java线程模型-JMM

> 试图屏蔽各种硬件与操作系统的内存访问差异
>
> 定义程序中各种共享变量的访问规则，实例字段、静态字段

<img src="https://vip2.loli.io/2022/09/08/Q1BUXo2IWDOqfdr.png" alt="image-20220908120140243" style="zoom:50%;" />

### 主内存和工作内存

+ `主内存`Java堆中的实例数据部分，更为底层可以对应物理内存
+ `工作内存` 虚拟机栈中的部分数据，更为底层可以对应寄存器、高速缓存。
+ 线程对变量的所有操作都必须在工作内存中进行，不能直接操作主内存
+ 线程间变量的传递均需通过主内存来完成

> 所有的变量都存储在主内存中，同时在各个线程的工作内存中存在变量的副本，提高效率的同时，引入了更为复杂的数据一致性问题

<img src="https://vip2.loli.io/2022/09/08/fhCdaUxvGpkoi7O.png" alt="image-20220908121357610" style="zoom:50%;" />

### volatile

1. 保证被修饰的变量对**所有**线程的`可见性`。一个线程修改了此变量，所有其他线程可以**立即**得知。虽然解决了变量的一致性问题，但是Java的运算符却并不是原子操作，因此在Java中volatile变量的运算操作并不是线程安全的。如下图中的L3，一个自增操作在对应着三条汇编指令。

   + 运算结果不依赖变量的当前值
   + 不与其他变量共同进行约束

   <img src="https://vip2.loli.io/2022/09/08/ZNcP3AjeFpatB8T.png" alt="image-20220908122435549" style="zoom:50%;" />

2. 禁止指令重排优化

   >  volatile变量的读操作的性能消耗跟普通变量基本一样，不过写操作因为需要插入`内存屏障`，因此会慢一些

3. 64bit变量的规则

   > 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为**两次**32位的操作来进行。不过在64位的虚拟机中并不会分成两次

### 可见性

1. `volatile`保证新增立即同步到主存，每次使用前失效工作内存，从主内存刷新。
2. `synchronized` unlock操作之前把此变量同步回主内存。

## 线程

> 线程是Java里面进行处理器资源调度的**最基本**单位

### 实现方式

1. 内核线程实现

   > 轻量级进程(线程)与内核线程1:1实现，完全由操作系统进行调度，Java实现此种方式

   + 一个被阻塞不会影响其他
   + 系统调用需要切换用户态、内核态

2. 用户线程实现
3. 混合实现

## Java线程

### 实现

> 每一个Java线程都是直接映射到一个操作系统原生线程，调动全权由底层操作系统处理

### 调度

> 线程调度是指系统为线程分配处理器使用权的过程

+ 协同式。线程执行完主动进行线程切换，Lua
+ 抢占式。定时中断

### 状态转换

1. new
2. running
3. waiting
4. time waiting
5. block
6. terminated

<img src="https://vip2.loli.io/2022/09/08/l2MVUkR3qFaSoiD.png" alt="image-20220908130043239" style="zoom: 67%;" />

## Java与协程

> 线程映射到操作系统，在微服务高响应的情况下，线程切换、调度的开销可能会接近于计算本身需要的开销，并且系统能容纳的线程数量十分有限。

### 线程切换

线程A -> `系统中断` -> 线程B

+ 程序员。各种局部变量和资源
+ 线程。 调用栈中存储的各类信息
+ 操作系统。 存储在内存、缓存以及寄存器的一个个具体数值

### 协程

1. 应用自己模拟多线程的调用方式
2. 协调式调度

#### 种类

1. 有栈协程。Stackfull Coroutine。完整的调用栈保护、恢复工作
2. 无栈协程。 Stackless Coroutine。有限状态机，状态保存在闭包中，如await、async、yield

### 线程栈大小

+ 64位的HotSpot中，默认是`1MB`

  ```sh
  # 线程栈默认容量
  -Xss
  -XX:ThreadStackSize
  ```

+ 协程通常在几百个字节到几KB

## 纤程(peer)

> Loom Project

1. 执行过程 -> 维护执行现场、保护、恢复上下文状态
2. 调度器 -> 负责编排要执行的代码顺序
3. 两者分离的好处，用户可以自行组合。

# Java锁

## 线程安全实现

### 互斥同步

+ 临界区
+ 互斥量
+ 信号量

> Java中使用synchronized关键字，经过编译后在代码块前后生成，monitorentry、monitorexit两个字节码指令

## sync和Lock

+ ReentryLock相比sync新增了以下特性
  1. 等待可中断
  2. 公平锁
  3. 锁绑定多个条件

+ sync在JDK6中加入了大量的优化，在两者都满足的情况下，优先使用sync
  1. 语法层面，简单清晰
  2. sync会自动释放锁，编码更不易出错
  3. 更容易被JVM针对优化

## 非阻塞同步

> Compare-and Swap -> CAS

### 优点

1. 无需用户态到核心态的切换
2. 无需维护锁计数器
3. 无需检查是否有线程需要被唤醒

### 缺点

1. ABA问题
2. 竞争激烈的情况下，容易空转

### 基本组成

1. 内存值 V
2. 旧的预期值 A
3. 准备设置的新值 B

```java
while(!CAS(V,A,B)){
  // do something
}
```

## 锁优化

1. 锁粗化
2. 锁消除
3. 自旋锁、自适应锁
4. 轻量级锁
5. 偏向锁



### 

